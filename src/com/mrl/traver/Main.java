package com.mrl.traver;

public class Main
{
    public static void main(String[] args) {
        
        //使用具体的策略 2）在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。2）
        //策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，
        //但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。
//        PersonContext personContext = new PersonContext(new TravelByAir());
//        personContext.travel();
    
//        
//        工厂模式是创建型模式 ，它关注对象创建，提供创建对象的接口.
//            让对象的创建与具体的使用客户无关。
//        策略模式是对象行为型模式 ，它关注行为和算法的封装 。
//        它定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。使得算法可独立于使用它的客户而变化
//        
//        
        
        //结合起来
        
        
    }
}
